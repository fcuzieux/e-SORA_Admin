import {
  require_jszip_min
} from "./chunk-3FD2SXPG.js";
import {
  __commonJS
} from "./chunk-PLDDJCW6.js";

// node_modules/docx-templates/lib/zip.js
var require_zip = __commonJS({
  "node_modules/docx-templates/lib/zip.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zipSave = exports.zipSetText = exports.zipGetText = exports.zipLoad = void 0;
    var jszip_1 = __importDefault(require_jszip_min());
    var zipLoad = function(inputFile) {
      return jszip_1.default.loadAsync(inputFile);
    };
    exports.zipLoad = zipLoad;
    var zipGetText = function(zip, filename) {
      var file_in_zip = zip.file(filename);
      if (!file_in_zip)
        return null;
      return file_in_zip.async("text");
    };
    exports.zipGetText = zipGetText;
    var zipSetText = function(zip, filename, data) {
      return zip.file(filename, data, { binary: false });
    };
    exports.zipSetText = zipSetText;
    var zipSave = function(zip) {
      return zip.generateAsync({
        type: "uint8array",
        compression: "DEFLATE",
        compressionOptions: { level: 1 }
      });
    };
    exports.zipSave = zipSave;
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self.lastNeed = 0;
        return "�";
      }
      if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self.lastNeed = 1;
          return "�";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "�";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = require_stream().Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      if (!Stream) Stream = function() {
      };
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require_string_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                if (parser.opt.unparsedEntities) {
                  var parsedEntity = parseEntity(parser);
                  parser.entity = "";
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer] += parseEntity(parser);
                  parser.entity = "";
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/docx-templates/lib/debug.js
var require_debug = __commonJS({
  "node_modules/docx-templates/lib/debug.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setDebugLogSink = exports.logger = void 0;
    exports.logger = { debug: function() {
    } };
    function setDebugLogSink(f) {
      exports.logger.debug = f;
    }
    exports.setDebugLogSink = setDebugLogSink;
  }
});

// node_modules/docx-templates/lib/xml.js
var require_xml = __commonJS({
  "node_modules/docx-templates/lib/xml.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildXml = exports.parseXml = void 0;
    var sax_1 = __importDefault(require_sax());
    var debug_1 = require_debug();
    var parseXml = function(templateXml) {
      var parser = sax_1.default.parser(true, {
        // true for XML-like (false for HTML-like)
        trim: false,
        normalize: false
      });
      var template;
      var curNode = null;
      var numXmlElements = 0;
      return new Promise(function(resolve, reject) {
        parser.onopentag = function(node) {
          var newNode = {
            _parent: curNode || void 0,
            _children: [],
            _fTextNode: false,
            _tag: node.name,
            _attrs: node.attributes
          };
          if (curNode != null)
            curNode._children.push(newNode);
          else
            template = newNode;
          curNode = newNode;
          numXmlElements += 1;
        };
        parser.onclosetag = function() {
          curNode = curNode != null ? curNode._parent : null;
        };
        parser.ontext = function(text) {
          if (curNode == null)
            return;
          curNode._children.push({
            _parent: curNode,
            _children: [],
            _fTextNode: true,
            _text: text
          });
        };
        parser.onend = function() {
          debug_1.logger.debug("Number of XML elements: ".concat(numXmlElements));
          resolve(template);
        };
        parser.onerror = function(err) {
          reject(err);
        };
        parser.write(templateXml);
        parser.end();
      });
    };
    exports.parseXml = parseXml;
    function buildXml(node, options, indent) {
      if (indent === void 0) {
        indent = "";
      }
      var xml = indent.length ? "" : '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
      var xmlBuffers = [Buffer.from(xml, "utf-8")];
      if (node._fTextNode)
        xmlBuffers.push(Buffer.from(sanitizeText(node._text, options)));
      else {
        var attrs_1 = "";
        var nodeAttrs_1 = node._attrs;
        Object.keys(nodeAttrs_1).forEach(function(key) {
          attrs_1 += " ".concat(key, '="').concat(sanitizeAttr(nodeAttrs_1[key]), '"');
        });
        var fHasChildren = node._children.length > 0;
        var suffix = fHasChildren ? "" : "/";
        xmlBuffers.push(Buffer.from("\n".concat(indent, "<").concat(node._tag).concat(attrs_1).concat(suffix, ">")));
        var fLastChildIsNode_1 = false;
        node._children.forEach(function(child) {
          xmlBuffers.push(buildXml(child, options, "".concat(indent, "  ")));
          fLastChildIsNode_1 = !child._fTextNode;
        });
        if (fHasChildren) {
          var indent2 = fLastChildIsNode_1 ? "\n".concat(indent) : "";
          xmlBuffers.push(Buffer.from("".concat(indent2, "</").concat(node._tag, ">")));
        }
      }
      return Buffer.concat(xmlBuffers);
    }
    exports.buildXml = buildXml;
    var sanitizeText = function(str, options) {
      var out = "";
      var segments = str.split(options.literalXmlDelimiter);
      var fLiteral = false;
      for (var i = 0; i < segments.length; i++) {
        var processedSegment = segments[i];
        if (!fLiteral) {
          processedSegment = processedSegment.replace(/&/g, "&amp;");
          processedSegment = processedSegment.replace(/</g, "&lt;");
          processedSegment = processedSegment.replace(/>/g, "&gt;");
        }
        out += processedSegment;
        fLiteral = !fLiteral;
      }
      return out;
    };
    var sanitizeAttr = function(attr) {
      var out = typeof attr === "string" ? attr : attr.value;
      out = out.replace(/&/g, "&amp;");
      out = out.replace(/</g, "&lt;");
      out = out.replace(/>/g, "&gt;");
      out = out.replace(/'/g, "&apos;");
      out = out.replace(/"/g, "&quot;");
      return out;
    };
  }
});

// node_modules/docx-templates/lib/errors.js
var require_errors = __commonJS({
  "node_modules/docx-templates/lib/errors.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnterminatedForLoopError = exports.IncompleteConditionalStatementError = exports.TemplateParseError = exports.InternalError = exports.ImageError = exports.CommandExecutionError = exports.InvalidCommandError = exports.CommandSyntaxError = exports.ObjectCommandResultError = exports.NullishCommandResultError = exports.isError = void 0;
    function isError(err) {
      return err instanceof Error || typeof err === "object" && !!err && "name" in err && "message" in err;
    }
    exports.isError = isError;
    var NullishCommandResultError = (
      /** @class */
      function(_super) {
        __extends(NullishCommandResultError2, _super);
        function NullishCommandResultError2(command) {
          var _this = _super.call(this, "Result of command ".concat(command, " is null or undefined and rejectNullish is set")) || this;
          Object.setPrototypeOf(_this, NullishCommandResultError2.prototype);
          _this.command = command;
          return _this;
        }
        return NullishCommandResultError2;
      }(Error)
    );
    exports.NullishCommandResultError = NullishCommandResultError;
    var ObjectCommandResultError = (
      /** @class */
      function(_super) {
        __extends(ObjectCommandResultError2, _super);
        function ObjectCommandResultError2(command, result) {
          var _this = _super.call(this, "Result of command '".concat(command, "' is an object")) || this;
          Object.setPrototypeOf(_this, ObjectCommandResultError2.prototype);
          _this.command = command;
          _this.result = result;
          return _this;
        }
        return ObjectCommandResultError2;
      }(Error)
    );
    exports.ObjectCommandResultError = ObjectCommandResultError;
    var CommandSyntaxError = (
      /** @class */
      function(_super) {
        __extends(CommandSyntaxError2, _super);
        function CommandSyntaxError2(command) {
          var _this = _super.call(this, "Invalid command syntax: ".concat(command)) || this;
          Object.setPrototypeOf(_this, CommandSyntaxError2.prototype);
          _this.command = command;
          return _this;
        }
        return CommandSyntaxError2;
      }(Error)
    );
    exports.CommandSyntaxError = CommandSyntaxError;
    var InvalidCommandError = (
      /** @class */
      function(_super) {
        __extends(InvalidCommandError2, _super);
        function InvalidCommandError2(msg, command) {
          var _this = _super.call(this, "".concat(msg, ": ").concat(command)) || this;
          Object.setPrototypeOf(_this, InvalidCommandError2.prototype);
          _this.command = command;
          return _this;
        }
        return InvalidCommandError2;
      }(Error)
    );
    exports.InvalidCommandError = InvalidCommandError;
    var CommandExecutionError = (
      /** @class */
      function(_super) {
        __extends(CommandExecutionError2, _super);
        function CommandExecutionError2(err, command) {
          var _this = _super.call(this, "Error executing command '".concat(command, "': ").concat(err.name, ": ").concat(err.message)) || this;
          Object.setPrototypeOf(_this, CommandExecutionError2.prototype);
          _this.command = command;
          _this.err = err;
          return _this;
        }
        return CommandExecutionError2;
      }(Error)
    );
    exports.CommandExecutionError = CommandExecutionError;
    var ImageError = (
      /** @class */
      function(_super) {
        __extends(ImageError2, _super);
        function ImageError2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return ImageError2;
      }(CommandExecutionError)
    );
    exports.ImageError = ImageError;
    var InternalError = (
      /** @class */
      function(_super) {
        __extends(InternalError2, _super);
        function InternalError2(msg) {
          return _super.call(this, "INTERNAL ERROR: ".concat(msg)) || this;
        }
        return InternalError2;
      }(Error)
    );
    exports.InternalError = InternalError;
    var TemplateParseError = (
      /** @class */
      function(_super) {
        __extends(TemplateParseError2, _super);
        function TemplateParseError2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return TemplateParseError2;
      }(Error)
    );
    exports.TemplateParseError = TemplateParseError;
    var IncompleteConditionalStatementError = (
      /** @class */
      function(_super) {
        __extends(IncompleteConditionalStatementError2, _super);
        function IncompleteConditionalStatementError2() {
          return _super.call(this, "Incomplete IF/END-IF statement. Make sure each IF-statement has a corresponding END-IF command.") || this;
        }
        return IncompleteConditionalStatementError2;
      }(Error)
    );
    exports.IncompleteConditionalStatementError = IncompleteConditionalStatementError;
    var UnterminatedForLoopError = (
      /** @class */
      function(_super) {
        __extends(UnterminatedForLoopError2, _super);
        function UnterminatedForLoopError2(loop) {
          return _super.call(this, "Unterminated FOR-loop ('FOR ".concat(loop.varName, "'). Make sure each FOR loop has a corresponding END-FOR command.")) || this;
        }
        return UnterminatedForLoopError2;
      }(Error)
    );
    exports.UnterminatedForLoopError = UnterminatedForLoopError;
  }
});

// node_modules/docx-templates/lib/reportUtils.js
var require_reportUtils = __commonJS({
  "node_modules/docx-templates/lib/reportUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logLoop = exports.isLoopExploring = exports.getCurLoop = exports.addChild = exports.newTextNode = exports.newNonTextNode = exports.insertTextSiblingAfter = exports.getNextSibling = exports.cloneNodeWithoutChildren = void 0;
    var errors_1 = require_errors();
    var debug_1 = require_debug();
    var cloneNodeWithoutChildren = function(node) {
      if (node._fTextNode) {
        return {
          _children: [],
          _fTextNode: true,
          _text: node._text
        };
      }
      return {
        _children: [],
        _fTextNode: false,
        _tag: node._tag,
        _attrs: node._attrs
      };
    };
    exports.cloneNodeWithoutChildren = cloneNodeWithoutChildren;
    var getNextSibling = function(node) {
      var parent = node._parent;
      if (parent == null)
        return null;
      var siblings = parent._children;
      var idx = siblings.indexOf(node);
      if (idx < 0 || idx >= siblings.length - 1)
        return null;
      return siblings[idx + 1];
    };
    exports.getNextSibling = getNextSibling;
    var insertTextSiblingAfter = function(textNode) {
      var tNode = textNode._parent;
      if (!(tNode && !tNode._fTextNode && tNode._tag === "w:t")) {
        throw new errors_1.TemplateParseError("Template syntax error: text node not within w:t");
      }
      var tNodeParent = tNode._parent;
      if (tNodeParent == null)
        throw new errors_1.TemplateParseError("Template syntax error: w:t node has no parent");
      var idx = tNodeParent._children.indexOf(tNode);
      if (idx < 0)
        throw new errors_1.TemplateParseError("Template syntax error");
      var newTNode = cloneNodeWithoutChildren(tNode);
      newTNode._parent = tNodeParent;
      var newTextNode2 = {
        _parent: newTNode,
        _children: [],
        _fTextNode: true,
        _text: ""
      };
      newTNode._children = [newTextNode2];
      tNodeParent._children.splice(idx + 1, 0, newTNode);
      return newTextNode2;
    };
    exports.insertTextSiblingAfter = insertTextSiblingAfter;
    var newNonTextNode = function(tag, attrs, children) {
      if (attrs === void 0) {
        attrs = {};
      }
      if (children === void 0) {
        children = [];
      }
      var node = {
        _fTextNode: false,
        _tag: tag,
        _attrs: attrs,
        _children: children
      };
      node._children.forEach(function(child) {
        child._parent = node;
      });
      return node;
    };
    exports.newNonTextNode = newNonTextNode;
    var newTextNode = function(text) {
      var node = { _children: [], _fTextNode: true, _text: text };
      return node;
    };
    exports.newTextNode = newTextNode;
    var addChild = function(parent, child) {
      parent._children.push(child);
      child._parent = parent;
      return child;
    };
    exports.addChild = addChild;
    var getCurLoop = function(ctx) {
      if (!ctx.loops.length)
        return null;
      return ctx.loops[ctx.loops.length - 1];
    };
    exports.getCurLoop = getCurLoop;
    var isLoopExploring = function(ctx) {
      var curLoop = getCurLoop(ctx);
      return curLoop != null && curLoop.idx < 0;
    };
    exports.isLoopExploring = isLoopExploring;
    var logLoop = function(loops) {
      if (!loops.length)
        return;
      var level = loops.length - 1;
      var _a = loops[level], varName = _a.varName, idx = _a.idx, loopOver = _a.loopOver, isIf = _a.isIf;
      var idxStr = idx >= 0 ? idx + 1 : "EXPLORATION";
      debug_1.logger.debug("".concat(isIf ? "IF" : "FOR", " loop ") + "on ".concat(level, ":").concat(varName) + "".concat(idxStr, "/").concat(loopOver.length));
    };
    exports.logLoop = logLoop;
  }
});

// node_modules/docx-templates/lib/preprocessTemplate.js
var require_preprocessTemplate = __commonJS({
  "node_modules/docx-templates/lib/preprocessTemplate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var reportUtils_1 = require_reportUtils();
    var preprocessTemplate = function(template, delimiter) {
      var node = template;
      var fCmd = false;
      var openNode = null;
      var idxDelimiter = 0;
      var placeholderCmd = "".concat(delimiter[0], "CMD_NODE").concat(delimiter[1]);
      while (node != null) {
        if (!node._fTextNode && node._tag === "w:t") {
          node._attrs["xml:space"] = "preserve";
        }
        if (!node._fTextNode && node._tag === "w:p" && openNode) {
          openNode._text += " ";
        }
        if (node._fTextNode && node._parent && !node._parent._fTextNode && node._parent._tag === "w:t") {
          if (openNode == null)
            openNode = node;
          var textIn = node._text;
          node._text = "";
          for (var i = 0; i < textIn.length; i++) {
            var c = textIn[i];
            var currentDelimiter = fCmd ? delimiter[1] : delimiter[0];
            if (c === currentDelimiter[idxDelimiter]) {
              idxDelimiter += 1;
              if (idxDelimiter === currentDelimiter.length) {
                fCmd = !fCmd;
                var fNodesMatch = node === openNode;
                if (fCmd && openNode._text.length) {
                  openNode = (0, reportUtils_1.insertTextSiblingAfter)(openNode);
                  if (fNodesMatch)
                    node = openNode;
                }
                openNode._text += currentDelimiter;
                if (!fCmd && i < textIn.length - 1) {
                  openNode = (0, reportUtils_1.insertTextSiblingAfter)(openNode);
                  if (fNodesMatch)
                    node = openNode;
                }
                idxDelimiter = 0;
                if (!fCmd)
                  openNode = node;
              }
            } else if (idxDelimiter) {
              openNode._text += currentDelimiter.slice(0, idxDelimiter);
              idxDelimiter = 0;
              if (!fCmd)
                openNode = node;
              openNode._text += c;
            } else {
              openNode._text += c;
            }
          }
          if (!fCmd && !idxDelimiter)
            openNode = null;
          if (textIn.length && !node._text.length)
            node._text = placeholderCmd;
        }
        if (node._children.length)
          node = node._children[0];
        else {
          var fFound = false;
          while (node._parent != null) {
            var nodeParent = node._parent;
            var nextSibling = (0, reportUtils_1.getNextSibling)(node);
            if (nextSibling) {
              fFound = true;
              node = nextSibling;
              break;
            }
            node = nodeParent;
          }
          if (!fFound)
            node = null;
        }
      }
      return template;
    };
    exports.default = preprocessTemplate;
  }
});

// browser-external:vm
var require_vm = __commonJS({
  "browser-external:vm"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "vm" has been externalized for browser compatibility. Cannot access "vm.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/docx-templates/lib/jsSandbox.js
var require_jsSandbox = __commonJS({
  "node_modules/docx-templates/lib/jsSandbox.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.runUserJsAndGetRaw = void 0;
    var vm_1 = __importDefault(require_vm());
    var reportUtils_1 = require_reportUtils();
    var errors_1 = require_errors();
    var debug_1 = require_debug();
    function runUserJsAndGetRaw(data, code, ctx) {
      return __awaiter(this, void 0, void 0, function() {
        var sandbox, curLoop, context, result, temp, wrapper, script, err_1, e, nerr;
        var _a;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              sandbox = __assign(__assign(__assign(__assign({}, ctx.jsSandbox || {}), { __code__: code, __result__: void 0 }), data), ctx.options.additionalJsContext);
              curLoop = (0, reportUtils_1.getCurLoop)(ctx);
              if (curLoop)
                sandbox.$idx = curLoop.idx;
              Object.keys(ctx.vars).forEach(function(varName) {
                sandbox["$".concat(varName)] = ctx.vars[varName];
              });
              _b.label = 1;
            case 1:
              _b.trys.push([1, 8, , 12]);
              if (!ctx.options.runJs) return [3, 3];
              temp = ctx.options.runJs({ sandbox, ctx });
              context = temp.modifiedSandbox;
              return [4, temp.result];
            case 2:
              result = _b.sent();
              return [3, 7];
            case 3:
              if (!ctx.options.noSandbox) return [3, 5];
              context = sandbox;
              wrapper = new Function("with(this) { return eval(__code__); }");
              return [4, wrapper.call(context)];
            case 4:
              result = _b.sent();
              return [3, 7];
            case 5:
              script = new vm_1.default.Script((_a = sandbox.__code__) !== null && _a !== void 0 ? _a : "");
              context = vm_1.default.createContext(sandbox);
              return [4, script.runInContext(context)];
            case 6:
              result = _b.sent();
              _b.label = 7;
            case 7:
              return [3, 12];
            case 8:
              err_1 = _b.sent();
              e = (0, errors_1.isError)(err_1) ? err_1 : new Error("".concat(err_1));
              if (!(ctx.options.errorHandler != null)) return [3, 10];
              context = sandbox;
              return [4, ctx.options.errorHandler(e, code)];
            case 9:
              result = _b.sent();
              return [3, 11];
            case 10:
              throw new errors_1.CommandExecutionError(e, code);
            case 11:
              return [3, 12];
            case 12:
              if (!(ctx.options.rejectNullish && result == null)) return [3, 15];
              nerr = new errors_1.NullishCommandResultError(code);
              if (!(ctx.options.errorHandler != null)) return [3, 14];
              return [4, ctx.options.errorHandler(nerr, code)];
            case 13:
              result = _b.sent();
              return [3, 15];
            case 14:
              throw nerr;
            case 15:
              ctx.jsSandbox = __assign(__assign({}, context), { __code__: void 0, __result__: void 0 });
              debug_1.logger.debug("Command returned: ", result);
              return [2, result];
          }
        });
      });
    }
    exports.runUserJsAndGetRaw = runUserJsAndGetRaw;
  }
});

// node_modules/docx-templates/lib/types.js
var require_types = __commonJS({
  "node_modules/docx-templates/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BUILT_IN_COMMANDS = exports.ImageExtensions = void 0;
    exports.ImageExtensions = [
      ".png",
      ".gif",
      ".jpg",
      ".jpeg",
      ".svg"
    ];
    exports.BUILT_IN_COMMANDS = [
      "QUERY",
      "CMD_NODE",
      "ALIAS",
      "FOR",
      "END-FOR",
      "IF",
      "END-IF",
      "INS",
      "EXEC",
      "IMAGE",
      "LINK",
      "HTML"
    ];
  }
});

// node_modules/docx-templates/lib/processTemplate.js
var require_processTemplate = __commonJS({
  "node_modules/docx-templates/lib/processTemplate.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitCommand = exports.getCommand = exports.walkTemplate = exports.findHighestImgId = exports.produceJsReport = exports.extractQuery = exports.newContext = void 0;
    var reportUtils_1 = require_reportUtils();
    var jsSandbox_1 = require_jsSandbox();
    var types_1 = require_types();
    var errors_1 = require_errors();
    var debug_1 = require_debug();
    function newContext(options, imageAndShapeIdIncrement) {
      if (imageAndShapeIdIncrement === void 0) {
        imageAndShapeIdIncrement = 0;
      }
      return {
        gCntIf: 0,
        gCntEndIf: 0,
        level: 1,
        fCmd: false,
        cmd: "",
        fSeekQuery: false,
        buffers: {
          "w:p": { text: "", cmds: "", fInsertedText: false },
          "w:tr": { text: "", cmds: "", fInsertedText: false },
          "w:tc": { text: "", cmds: "", fInsertedText: false }
        },
        imageAndShapeIdIncrement,
        images: {},
        linkId: 0,
        links: {},
        htmlId: 0,
        htmls: {},
        vars: {},
        loops: [],
        fJump: false,
        shorthands: {},
        options,
        // To verfiy we don't have a nested if within the same p or tr tag
        pIfCheckMap: /* @__PURE__ */ new Map(),
        trIfCheckMap: /* @__PURE__ */ new Map()
      };
    }
    exports.newContext = newContext;
    function extractQuery(template, options) {
      return __awaiter(this, void 0, void 0, function() {
        var ctx, nodeIn, fFound, parent_1, nextSibling, parent_2;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              ctx = newContext(options);
              ctx.fSeekQuery = true;
              nodeIn = template;
              _a.label = 1;
            case 1:
              if (false) return [3, 4];
              if (nodeIn._children.length)
                nodeIn = nodeIn._children[0];
              else {
                fFound = false;
                while (nodeIn._parent != null) {
                  parent_1 = nodeIn._parent;
                  nextSibling = (0, reportUtils_1.getNextSibling)(nodeIn);
                  if (nextSibling) {
                    nodeIn = nextSibling;
                    fFound = true;
                    break;
                  }
                  nodeIn = parent_1;
                }
                if (!fFound)
                  return [3, 4];
              }
              if (!nodeIn)
                return [3, 4];
              parent_2 = nodeIn._parent;
              if (!(nodeIn._fTextNode && parent_2 && !parent_2._fTextNode && parent_2._tag === "w:t")) return [3, 3];
              return [4, processText(null, nodeIn, ctx, processCmd)];
            case 2:
              _a.sent();
              _a.label = 3;
            case 3:
              if (ctx.query != null)
                return [3, 4];
              return [3, 1];
            case 4:
              return [2, ctx.query];
          }
        });
      });
    }
    exports.extractQuery = extractQuery;
    function produceJsReport(data, template, ctx) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          return [2, walkTemplate(data, template, ctx, processCmd)];
        });
      });
    }
    exports.produceJsReport = produceJsReport;
    function findHighestImgId(mainDoc) {
      var doc_ids = [];
      var search = function(n) {
        for (var _i = 0, _a = n._children; _i < _a.length; _i++) {
          var c = _a[_i];
          var tag = c._fTextNode ? null : c._tag;
          if (tag == null)
            continue;
          if (tag === "wp:docPr") {
            if (c._fTextNode)
              continue;
            var raw = c._attrs.id;
            if (typeof raw !== "string")
              continue;
            var id = Number.parseInt(raw, 10);
            if (Number.isSafeInteger(id))
              doc_ids.push(id);
          }
          if (c._children.length > 0)
            search(c);
        }
      };
      search(mainDoc);
      if (doc_ids.length > 0)
        return Math.max.apply(Math, doc_ids);
      return 0;
    }
    exports.findHighestImgId = findHighestImgId;
    var debugPrintNode = function(node) {
      return JSON.stringify(node._fTextNode ? {
        _ifName: node._ifName,
        _fTextNode: node._fTextNode,
        _text: node === null || node === void 0 ? void 0 : node._text
      } : {
        _ifName: node._ifName,
        _fTextNode: node._fTextNode,
        _tag: node === null || node === void 0 ? void 0 : node._tag,
        _attrs: node === null || node === void 0 ? void 0 : node._attrs
      });
    };
    var findParentPorTrNode = function(node) {
      var parentNode = node._parent;
      var resultNode = null;
      while (parentNode != null && resultNode == null) {
        var parentNodeTag = parentNode._fTextNode ? null : parentNode._tag;
        if (parentNodeTag === "w:p") {
          var grandParentNode = parentNode._parent != null ? parentNode._parent._parent : null;
          if (grandParentNode != null && !grandParentNode._fTextNode && grandParentNode._tag === "w:tr") {
            resultNode = grandParentNode;
          } else {
            resultNode = parentNode;
          }
        }
        parentNode = parentNode._parent;
      }
      return resultNode;
    };
    function walkTemplate(data, template, ctx, processor) {
      return __awaiter(this, void 0, void 0, function() {
        var out, nodeIn, nodeOut, move, deltaJump, errors, loopCount, maximumWalkingDepth, curLoop, nextSibling, parent_3, tag, fRemoveNode, buffers, nodeOutParent, imgNode, captionNodes, parent_4, linkNode, parent_5, htmlNode, parent_6, tag, newNode, newNodeTag, parent_7, result, err, innermost_loop, err;
        var _a;
        var _b;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              out = (0, reportUtils_1.cloneNodeWithoutChildren)(template);
              nodeIn = template;
              nodeOut = out;
              deltaJump = 0;
              errors = [];
              loopCount = 0;
              maximumWalkingDepth = ((_b = ctx.options) === null || _b === void 0 ? void 0 : _b.maximumWalkingDepth) || 1e6;
              _c.label = 1;
            case 1:
              if (false) return [3, 5];
              curLoop = (0, reportUtils_1.getCurLoop)(ctx);
              nextSibling = null;
              if (ctx.fJump) {
                if (!curLoop)
                  throw new errors_1.InternalError("jumping while curLoop is null");
                debug_1.logger.debug("Jumping to level ".concat(curLoop.refNodeLevel, "..."), debugPrintNode(curLoop.refNode));
                deltaJump = ctx.level - curLoop.refNodeLevel;
                nodeIn = curLoop.refNode;
                ctx.level = curLoop.refNodeLevel;
                ctx.fJump = false;
                move = "JUMP";
              } else if (nodeIn._children.length && move !== "UP") {
                nodeIn = nodeIn._children[0];
                ctx.level += 1;
                move = "DOWN";
              } else if (nextSibling = (0, reportUtils_1.getNextSibling)(nodeIn)) {
                nodeIn = nextSibling;
                move = "SIDE";
              } else {
                parent_3 = nodeIn._parent;
                if (parent_3 == null) {
                  debug_1.logger.debug("=== parent is null, breaking after ".concat(loopCount, " loops..."));
                  return [3, 5];
                } else if (loopCount > maximumWalkingDepth) {
                  debug_1.logger.debug("=== parent is still not null after ".concat(loopCount, " loops, something must be wrong ..."), debugPrintNode(parent_3));
                  throw new errors_1.InternalError("infinite loop or massive dataset detected. Please review and try again");
                }
                nodeIn = parent_3;
                ctx.level -= 1;
                move = "UP";
              }
              debug_1.logger.debug("Next node [".concat(move, ", level ").concat(ctx.level, "]"), debugPrintNode(nodeIn));
              if (move !== "DOWN") {
                tag = nodeOut._fTextNode ? null : nodeOut._tag;
                fRemoveNode = false;
                if ((tag === "w:p" || tag === "w:tbl" || tag === "w:tr" || tag === "w:tc") && (0, reportUtils_1.isLoopExploring)(ctx)) {
                  fRemoveNode = true;
                } else if (tag === "w:p" || tag === "w:tr" || tag === "w:tc") {
                  buffers = ctx.buffers[tag];
                  fRemoveNode = buffers.text === "" && buffers.cmds !== "" && !buffers.fInsertedText;
                  if (tag === "w:tr" && fRemoveNode) {
                    fRemoveNode = nodeIn._children.filter(function(child) {
                      return !child._fTextNode && child._tag === "w:tr";
                    }).length !== 1;
                  }
                  if (tag === "w:tc" && fRemoveNode) {
                    fRemoveNode = !(nodeOut._children.filter(function(child) {
                      return !child._fTextNode && child._tag === "w:tbl";
                    }).length > 0);
                  }
                }
                if (fRemoveNode && nodeOut._parent != null) {
                  nodeOut._parent._children.pop();
                }
              }
              if (move === "UP") {
                if ((0, reportUtils_1.isLoopExploring)(ctx) && curLoop && nodeIn === curLoop.refNode._parent) {
                  curLoop.refNode = nodeIn;
                  curLoop.refNodeLevel -= 1;
                  debug_1.logger.debug("Updated loop '".concat(curLoop.varName, "' refNode: ") + debugPrintNode(nodeIn));
                }
                nodeOutParent = nodeOut._parent;
                if (nodeOutParent == null)
                  throw new errors_1.InternalError("node parent is null");
                nodeOut = nodeOutParent;
                if (ctx.pendingImageNode && !nodeOut._fTextNode && nodeOut._tag === "w:t") {
                  imgNode = ctx.pendingImageNode.image;
                  captionNodes = ctx.pendingImageNode.caption;
                  parent_4 = nodeOut._parent;
                  if (parent_4) {
                    imgNode._parent = parent_4;
                    parent_4._children.pop();
                    parent_4._children.push(imgNode);
                    if (captionNodes) {
                      (_a = parent_4._children).push.apply(_a, captionNodes);
                    }
                    ctx.buffers["w:p"].fInsertedText = true;
                    ctx.buffers["w:tr"].fInsertedText = true;
                    ctx.buffers["w:tc"].fInsertedText = true;
                  }
                  delete ctx.pendingImageNode;
                }
                if (ctx.pendingLinkNode && !nodeOut._fTextNode && nodeOut._tag === "w:r") {
                  linkNode = ctx.pendingLinkNode;
                  parent_5 = nodeOut._parent;
                  if (parent_5) {
                    linkNode._parent = parent_5;
                    parent_5._children.pop();
                    parent_5._children.push(linkNode);
                    ctx.buffers["w:p"].fInsertedText = true;
                    ctx.buffers["w:tr"].fInsertedText = true;
                    ctx.buffers["w:tc"].fInsertedText = true;
                  }
                  delete ctx.pendingLinkNode;
                }
                if (ctx.pendingHtmlNode && !nodeOut._fTextNode && nodeOut._tag === "w:p") {
                  htmlNode = ctx.pendingHtmlNode;
                  parent_6 = nodeOut._parent;
                  if (parent_6) {
                    htmlNode._parent = parent_6;
                    parent_6._children.pop();
                    parent_6._children.push(htmlNode);
                    ctx.buffers["w:p"].fInsertedText = true;
                    ctx.buffers["w:tr"].fInsertedText = true;
                    ctx.buffers["w:tc"].fInsertedText = true;
                  }
                  delete ctx.pendingHtmlNode;
                }
                if (!nodeOut._fTextNode && nodeOut._tag === "w:tc" && !nodeOut._children.filter(function(o) {
                  return !o._fTextNode && (o._tag === "w:p" || o._tag === "w:altChunk");
                }).length) {
                  nodeOut._children.push({
                    _parent: nodeOut,
                    _children: [],
                    _fTextNode: false,
                    _tag: "w:p",
                    _attrs: {}
                  });
                }
                if (!nodeOut._fTextNode && nodeOut._tag === "w:rPr") {
                  ctx.textRunPropsNode = nodeOut;
                }
                if (!nodeIn._fTextNode && nodeIn._tag === "w:r") {
                  delete ctx.textRunPropsNode;
                }
              }
              if (!(move === "DOWN" || move === "SIDE")) return [3, 4];
              if (move === "SIDE") {
                if (nodeOut._parent == null)
                  throw new errors_1.InternalError("node parent is null");
                nodeOut = nodeOut._parent;
              }
              tag = nodeIn._fTextNode ? null : nodeIn._tag;
              if (tag === "w:p" || tag === "w:tr" || tag === "w:tc") {
                ctx.buffers[tag] = { text: "", cmds: "", fInsertedText: false };
              }
              newNode = (0, reportUtils_1.cloneNodeWithoutChildren)(nodeIn);
              newNode._parent = nodeOut;
              nodeOut._children.push(newNode);
              newNodeTag = newNode._tag;
              if (!(0, reportUtils_1.isLoopExploring)(ctx) && (newNodeTag === "wp:docPr" || newNodeTag === "v:shape")) {
                debug_1.logger.debug("detected a - ", debugPrintNode(newNode));
                updateID(newNode, ctx);
              }
              parent_7 = nodeIn._parent;
              if (!(nodeIn._fTextNode && parent_7 && !parent_7._fTextNode && parent_7._tag === "w:t")) return [3, 3];
              return [4, processText(data, nodeIn, ctx, processor)];
            case 2:
              result = _c.sent();
              if (typeof result === "string") {
                newNode._text = result;
                debug_1.logger.debug("Inserted command result string into node. Updated node: " + debugPrintNode(newNode));
              } else {
                errors.push.apply(errors, result);
              }
              _c.label = 3;
            case 3:
              nodeOut = newNode;
              _c.label = 4;
            case 4:
              if (move === "JUMP") {
                while (deltaJump > 0) {
                  if (nodeOut._parent == null)
                    throw new errors_1.InternalError("node parent is null");
                  nodeOut = nodeOut._parent;
                  deltaJump -= 1;
                }
              }
              loopCount++;
              return [3, 1];
            case 5:
              if (ctx.gCntIf !== ctx.gCntEndIf) {
                err = new errors_1.IncompleteConditionalStatementError();
                if (ctx.options.failFast) {
                  throw err;
                } else {
                  errors.push(err);
                }
              }
              if (ctx.loops.filter(function(l) {
                return !l.isIf;
              }).length > 0) {
                innermost_loop = ctx.loops[ctx.loops.length - 1];
                err = new errors_1.UnterminatedForLoopError(innermost_loop);
                if (ctx.options.failFast) {
                  throw err;
                } else {
                  errors.push(err);
                }
              }
              if (errors.length > 0)
                return [2, {
                  status: "errors",
                  errors
                }];
              return [2, {
                status: "success",
                report: out,
                images: ctx.images,
                links: ctx.links,
                htmls: ctx.htmls
              }];
          }
        });
      });
    }
    exports.walkTemplate = walkTemplate;
    var processText = function(data, node, ctx, onCommand) {
      return __awaiter(void 0, void 0, void 0, function() {
        var _a, cmdDelimiter, failFast, text, segments, outText, errors, idx, segment, cmdResultText;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _a = ctx.options, cmdDelimiter = _a.cmdDelimiter, failFast = _a.failFast;
              text = node._text;
              if (text == null || text === "")
                return [2, ""];
              segments = text.split(cmdDelimiter[0]).map(function(s) {
                return s.split(cmdDelimiter[1]);
              }).reduce(function(x, y) {
                return x.concat(y);
              });
              outText = "";
              errors = [];
              idx = 0;
              _b.label = 1;
            case 1:
              if (!(idx < segments.length)) return [3, 5];
              if (idx > 0)
                appendTextToTagBuffers(cmdDelimiter[0], ctx, { fCmd: true });
              segment = segments[idx];
              if (ctx.fCmd)
                ctx.cmd += segment;
              else if (!(0, reportUtils_1.isLoopExploring)(ctx))
                outText += segment;
              appendTextToTagBuffers(segment, ctx, { fCmd: ctx.fCmd });
              if (!(idx < segments.length - 1)) return [3, 4];
              if (!ctx.fCmd) return [3, 3];
              return [4, onCommand(data, node, ctx)];
            case 2:
              cmdResultText = _b.sent();
              if (cmdResultText != null) {
                if (typeof cmdResultText === "string") {
                  outText += cmdResultText;
                  appendTextToTagBuffers(cmdResultText, ctx, {
                    fCmd: false,
                    fInsertedText: true
                  });
                } else {
                  if (failFast)
                    throw cmdResultText;
                  errors.push(cmdResultText);
                }
              }
              _b.label = 3;
            case 3:
              ctx.fCmd = !ctx.fCmd;
              _b.label = 4;
            case 4:
              idx++;
              return [3, 1];
            case 5:
              if (errors.length > 0)
                return [2, errors];
              return [2, outText];
          }
        });
      });
    };
    var processCmd = function(data, node, ctx) {
      return __awaiter(void 0, void 0, void 0, function() {
        var cmd, _a, cmdName, cmdRest, aliasMatch, aliasName, fullCmd, result, nerr, str, literalXmlDelimiter, splitByLineBreak, LINE_BREAK, END_OF_TEXT, START_OF_TEXT, img, pars, html, err_1;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              cmd = getCommand(ctx.cmd, ctx.shorthands, ctx.options.fixSmartQuotes);
              ctx.cmd = "";
              _b.label = 1;
            case 1:
              _b.trys.push([1, 28, , 29]);
              _a = splitCommand(cmd), cmdName = _a.cmdName, cmdRest = _a.cmdRest;
              if (cmdName !== "CMD_NODE")
                debug_1.logger.debug("Processing cmd: ".concat(cmd));
              if (ctx.fSeekQuery) {
                if (cmdName === "QUERY")
                  ctx.query = cmdRest;
                return [
                  2
                  /*return*/
                ];
              }
              if (!(cmdName === "QUERY" || cmdName === "CMD_NODE")) return [3, 2];
              return [3, 27];
            case 2:
              if (!(cmdName === "ALIAS")) return [3, 3];
              aliasMatch = /^(\S+)\s+(.+)/.exec(cmdRest);
              if (!aliasMatch)
                throw new errors_1.InvalidCommandError("Invalid ALIAS command", cmd);
              aliasName = aliasMatch[1];
              fullCmd = aliasMatch[2];
              ctx.shorthands[aliasName] = fullCmd;
              debug_1.logger.debug("Defined alias '".concat(aliasName, "' for: ").concat(fullCmd));
              return [3, 27];
            case 3:
              if (!(cmdName === "FOR" || cmdName === "IF")) return [3, 5];
              return [4, processForIf(data, node, ctx, cmd, cmdName, cmdRest)];
            case 4:
              _b.sent();
              return [3, 27];
            case 5:
              if (!(cmdName === "END-FOR" || cmdName === "END-IF")) return [3, 6];
              processEndForIf(node, ctx, cmd, cmdName, cmdRest);
              return [3, 27];
            case 6:
              if (!(cmdName === "INS")) return [3, 12];
              if (!!(0, reportUtils_1.isLoopExploring)(ctx)) return [3, 11];
              return [4, (0, jsSandbox_1.runUserJsAndGetRaw)(data, cmdRest, ctx)];
            case 7:
              result = _b.sent();
              if (result == null) {
                return [2, ""];
              }
              if (!(typeof result === "object" && !Array.isArray(result))) return [3, 10];
              nerr = new errors_1.ObjectCommandResultError(cmdRest, result);
              if (!(ctx.options.errorHandler != null)) return [3, 9];
              return [4, ctx.options.errorHandler(nerr, cmdRest)];
            case 8:
              result = _b.sent();
              return [3, 10];
            case 9:
              throw nerr;
            case 10:
              str = String(result);
              if (ctx.options.processLineBreaks) {
                literalXmlDelimiter = ctx.options.literalXmlDelimiter;
                if (ctx.options.processLineBreaksAsNewText) {
                  splitByLineBreak = str.split("\n");
                  LINE_BREAK = "".concat(literalXmlDelimiter, "<w:br/>").concat(literalXmlDelimiter);
                  END_OF_TEXT = "".concat(literalXmlDelimiter, "</w:t>").concat(literalXmlDelimiter);
                  START_OF_TEXT = "".concat(literalXmlDelimiter, '<w:t xml:space="preserve">').concat(literalXmlDelimiter);
                  str = splitByLineBreak.join("".concat(END_OF_TEXT).concat(LINE_BREAK).concat(START_OF_TEXT));
                } else {
                  str = str.replace(/\n/g, "".concat(literalXmlDelimiter, "<w:br/>").concat(literalXmlDelimiter));
                }
              }
              return [2, str];
            case 11:
              return [3, 27];
            case 12:
              if (!(cmdName === "EXEC")) return [3, 15];
              if (!!(0, reportUtils_1.isLoopExploring)(ctx)) return [3, 14];
              return [4, (0, jsSandbox_1.runUserJsAndGetRaw)(data, cmdRest, ctx)];
            case 13:
              _b.sent();
              _b.label = 14;
            case 14:
              return [3, 27];
            case 15:
              if (!(cmdName === "IMAGE")) return [3, 18];
              if (!!(0, reportUtils_1.isLoopExploring)(ctx)) return [3, 17];
              return [4, (0, jsSandbox_1.runUserJsAndGetRaw)(data, cmdRest, ctx)];
            case 16:
              img = _b.sent();
              if (img != null) {
                try {
                  processImage(ctx, img);
                } catch (e) {
                  if (!(0, errors_1.isError)(e))
                    throw e;
                  throw new errors_1.ImageError(e, cmd);
                }
              }
              _b.label = 17;
            case 17:
              return [3, 27];
            case 18:
              if (!(cmdName === "LINK")) return [3, 22];
              if (!!(0, reportUtils_1.isLoopExploring)(ctx)) return [3, 21];
              return [4, (0, jsSandbox_1.runUserJsAndGetRaw)(data, cmdRest, ctx)];
            case 19:
              pars = _b.sent();
              if (!(pars != null)) return [3, 21];
              return [4, processLink(ctx, pars)];
            case 20:
              _b.sent();
              _b.label = 21;
            case 21:
              return [3, 27];
            case 22:
              if (!(cmdName === "HTML")) return [3, 26];
              if (!!(0, reportUtils_1.isLoopExploring)(ctx)) return [3, 25];
              return [4, (0, jsSandbox_1.runUserJsAndGetRaw)(data, cmdRest, ctx)];
            case 23:
              html = _b.sent();
              if (!(html != null)) return [3, 25];
              return [4, processHtml(ctx, html)];
            case 24:
              _b.sent();
              _b.label = 25;
            case 25:
              return [3, 27];
            case 26:
              throw new errors_1.CommandSyntaxError(cmd);
            case 27:
              return [
                2
                /*return*/
              ];
            case 28:
              err_1 = _b.sent();
              if (!(0, errors_1.isError)(err_1))
                throw err_1;
              if (ctx.options.errorHandler != null) {
                return [2, ctx.options.errorHandler(err_1)];
              }
              return [2, err_1];
            case 29:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var builtInRegexes = types_1.BUILT_IN_COMMANDS.map(function(word) {
      return new RegExp("^".concat(word, "\\b"));
    });
    var notBuiltIns = function(cmd) {
      return !builtInRegexes.some(function(r) {
        return r.test(cmd.toUpperCase());
      });
    };
    function getCommand(command, shorthands, fixSmartQuotes) {
      var cmd = command.trim();
      if (cmd[0] === "*") {
        var aliasName = cmd.slice(1).trim();
        if (!shorthands[aliasName])
          throw new errors_1.InvalidCommandError("Unknown alias", cmd);
        cmd = shorthands[aliasName];
        debug_1.logger.debug("Alias for: ".concat(cmd));
      } else if (cmd[0] === "=") {
        cmd = "INS ".concat(cmd.slice(1).trim());
      } else if (cmd[0] === "!") {
        cmd = "EXEC ".concat(cmd.slice(1).trim());
      } else if (notBuiltIns(cmd)) {
        cmd = "INS ".concat(cmd.trim());
      }
      if (fixSmartQuotes) {
        cmd = cmd.replace(/[\u201C\u201D\u201E]/g, '"').replace(/[\u2018\u2019\u201A]/g, "'");
      }
      return cmd.trim();
    }
    exports.getCommand = getCommand;
    function splitCommand(cmd) {
      var cmdNameMatch = /^(\S+)\s*/.exec(cmd);
      var cmdName;
      var cmdRest = "";
      if (cmdNameMatch != null) {
        cmdName = cmdNameMatch[1].toUpperCase();
        cmdRest = cmd.slice(cmdName.length).trim();
      }
      return { cmdName, cmdRest };
    }
    exports.splitCommand = splitCommand;
    var processForIf = function(data, node, ctx, cmd, cmdName, cmdRest) {
      return __awaiter(void 0, void 0, void 0, function() {
        var isIf, forMatch, varName, curLoop, parentPorTrNode, parentPorTrNodeTag, parentLoopLevel, fParentIsExploring, loopOver, shouldRun;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              isIf = cmdName === "IF";
              forMatch = null;
              varName = void 0;
              if (isIf) {
                if (!node._ifName) {
                  node._ifName = "__if_".concat(ctx.gCntIf);
                  ctx.gCntIf += 1;
                }
                varName = node._ifName;
              } else {
                forMatch = /^(\S+)\s+IN\s+(.+)/i.exec(cmdRest);
                if (!forMatch)
                  throw new errors_1.InvalidCommandError("Invalid FOR command", cmd);
                varName = forMatch[1];
              }
              curLoop = (0, reportUtils_1.getCurLoop)(ctx);
              if (!!(curLoop && curLoop.varName === varName)) return [3, 6];
              if (isIf) {
                parentPorTrNode = findParentPorTrNode(node);
                parentPorTrNodeTag = parentPorTrNode != null ? parentPorTrNode._fTextNode ? null : parentPorTrNode._tag : null;
                if (parentPorTrNode != null) {
                  if (parentPorTrNodeTag === "w:p") {
                    if (ctx.pIfCheckMap.has(parentPorTrNode) && ctx.pIfCheckMap.get(parentPorTrNode) !== cmd)
                      throw new errors_1.InvalidCommandError("Invalid IF command nested into another IF command on the same line", cmd);
                    else
                      ctx.pIfCheckMap.set(parentPorTrNode, cmd);
                  } else if (parentPorTrNodeTag === "w:tr") {
                    if (ctx.trIfCheckMap.has(parentPorTrNode) && ctx.trIfCheckMap.get(parentPorTrNode) !== cmd)
                      throw new errors_1.InvalidCommandError("Invalid IF command nested into another IF command on the same table row", cmd);
                    else
                      ctx.trIfCheckMap.set(parentPorTrNode, cmd);
                  }
                }
              }
              parentLoopLevel = ctx.loops.length - 1;
              fParentIsExploring = parentLoopLevel >= 0 && ctx.loops[parentLoopLevel].idx === -1;
              loopOver = void 0;
              if (!fParentIsExploring) return [3, 1];
              loopOver = [];
              return [3, 5];
            case 1:
              if (!isIf) return [3, 3];
              return [4, (0, jsSandbox_1.runUserJsAndGetRaw)(data, cmdRest, ctx)];
            case 2:
              shouldRun = !!_a.sent();
              loopOver = shouldRun ? [1] : [];
              return [3, 5];
            case 3:
              if (!forMatch)
                throw new errors_1.InvalidCommandError("Invalid FOR command", cmd);
              return [4, (0, jsSandbox_1.runUserJsAndGetRaw)(data, forMatch[2], ctx)];
            case 4:
              loopOver = _a.sent();
              if (!Array.isArray(loopOver))
                throw new errors_1.InvalidCommandError("Invalid FOR command (can only iterate over Array)", cmd);
              _a.label = 5;
            case 5:
              ctx.loops.push({
                refNode: node,
                refNodeLevel: ctx.level,
                varName,
                loopOver,
                isIf,
                // run through the loop once first, without outputting anything
                // (if we don't do it like this, we could not run empty loops!)
                idx: -1
              });
              _a.label = 6;
            case 6:
              (0, reportUtils_1.logLoop)(ctx.loops);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var processEndForIf = function(node, ctx, cmd, cmdName, cmdRest) {
      var isIf = cmdName === "END-IF";
      var curLoop = (0, reportUtils_1.getCurLoop)(ctx);
      if (!curLoop)
        throw new errors_1.InvalidCommandError("Unexpected ".concat(cmdName, " outside of ").concat(isIf ? "IF statement" : "FOR loop", " context"), cmd);
      var parentPorTrNode = findParentPorTrNode(node);
      var parentPorTrNodeTag = parentPorTrNode != null ? parentPorTrNode._fTextNode ? null : parentPorTrNode._tag : null;
      if (parentPorTrNodeTag === "w:p") {
        ctx.pIfCheckMap.delete(parentPorTrNode);
      } else if (parentPorTrNodeTag === "w:tr") {
        ctx.trIfCheckMap.delete(parentPorTrNode);
      }
      if (isIf && !node._ifName) {
        node._ifName = curLoop.varName;
        ctx.gCntEndIf += 1;
      }
      var varName = isIf ? node._ifName : cmdRest;
      if (curLoop.varName !== varName) {
        if (ctx.loops.find(function(o) {
          return o.varName === varName;
        }) == null) {
          debug_1.logger.debug("Ignoring ".concat(cmd, " (").concat(varName, ", but we're expecting ").concat(curLoop.varName, ")"));
          return;
        }
        throw new errors_1.InvalidCommandError("Invalid command", cmd);
      }
      var nextIdx = curLoop.idx + 1;
      var nextItem = curLoop.loopOver[nextIdx];
      if (nextItem != null) {
        ctx.vars[varName] = nextItem;
        ctx.fJump = true;
        curLoop.idx = nextIdx;
      } else {
        ctx.loops.pop();
      }
    };
    var imageToContext = function(ctx, img) {
      validateImage(img);
      ctx.imageAndShapeIdIncrement += 1;
      var id = String(ctx.imageAndShapeIdIncrement);
      var relId = "img".concat(id);
      ctx.images[relId] = img;
      return relId;
    };
    function validateImage(img) {
      if (!(img.data instanceof Uint8Array || img.data instanceof ArrayBuffer || typeof img.data === "string")) {
        throw new Error("image .data property needs to be provided as Uint8Array (e.g. Buffer), ArrayBuffer, or as a base64-encoded string");
      }
      if (!types_1.ImageExtensions.includes(img.extension)) {
        throw new Error("An extension (one of ".concat(types_1.ImageExtensions, ") needs to be provided when providing an image or a thumbnail."));
      }
    }
    function validateImagePars(pars) {
      if (!Number.isFinite(pars.width))
        throw new Error("invalid image width: ".concat(pars.width, " (in cm)"));
      if (!Number.isFinite(pars.height))
        throw new Error("invalid image height: ".concat(pars.height, " (in cm)"));
      validateImage(pars);
      if (pars.thumbnail)
        validateImage(pars.thumbnail);
    }
    var processImage = function(ctx, imagePars) {
      var _a;
      validateImagePars(imagePars);
      var cx = (imagePars.width * 36e4).toFixed(0);
      var cy = (imagePars.height * 36e4).toFixed(0);
      var imgRelId = imageToContext(ctx, getImageData(imagePars));
      var id = String(ctx.imageAndShapeIdIncrement);
      var alt = imagePars.alt || "desc";
      var node = reportUtils_1.newNonTextNode;
      var extNodes = [];
      extNodes.push(node("a:ext", { uri: "{28A0092B-C50C-407E-A947-70E740481C1C}" }, [
        node("a14:useLocalDpi", {
          "xmlns:a14": "http://schemas.microsoft.com/office/drawing/2010/main",
          val: "0"
        })
      ]));
      var rot = imagePars.rotation ? (imagePars.rotation * 6e4).toString() : void 0;
      if (ctx.images[imgRelId].extension === ".svg") {
        var thumbnail = (_a = imagePars.thumbnail) !== null && _a !== void 0 ? _a : {
          data: "bm90aGluZwo=",
          extension: ".png"
        };
        var thumbRelId = imageToContext(ctx, thumbnail);
        extNodes.push(node("a:ext", { uri: "{96DAC541-7B7A-43D3-8B79-37D633B846F1}" }, [
          node("asvg:svgBlip", {
            "xmlns:asvg": "http://schemas.microsoft.com/office/drawing/2016/SVG/main",
            "r:embed": imgRelId
          })
        ]));
        imgRelId = thumbRelId;
      }
      var pic = node("pic:pic", { "xmlns:pic": "http://schemas.openxmlformats.org/drawingml/2006/picture" }, [
        node("pic:nvPicPr", {}, [
          node("pic:cNvPr", { id: "0", name: "Picture ".concat(id), descr: alt }),
          node("pic:cNvPicPr", {}, [
            node("a:picLocks", { noChangeAspect: "1", noChangeArrowheads: "1" })
          ])
        ]),
        node("pic:blipFill", {}, [
          node("a:blip", { "r:embed": imgRelId, cstate: "print" }, [
            node("a:extLst", {}, extNodes)
          ]),
          node("a:srcRect"),
          node("a:stretch", {}, [node("a:fillRect")])
        ]),
        node("pic:spPr", { bwMode: "auto" }, [
          node("a:xfrm", rot ? { rot } : {}, [
            node("a:off", { x: "0", y: "0" }),
            node("a:ext", { cx, cy })
          ]),
          node("a:prstGeom", { prst: "rect" }, [node("a:avLst")]),
          node("a:noFill"),
          node("a:ln", {}, [node("a:noFill")])
        ])
      ]);
      var drawing = node("w:drawing", {}, [
        node("wp:inline", { distT: "0", distB: "0", distL: "0", distR: "0" }, [
          node("wp:extent", { cx, cy }),
          node("wp:docPr", { id, name: "Picture ".concat(id), descr: alt }),
          node("wp:cNvGraphicFramePr", {}, [
            node("a:graphicFrameLocks", {
              "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main",
              noChangeAspect: "1"
            })
          ]),
          node("a:graphic", { "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main" }, [
            node("a:graphicData", { uri: "http://schemas.openxmlformats.org/drawingml/2006/picture" }, [pic])
          ])
        ])
      ]);
      ctx.pendingImageNode = { image: drawing };
      if (imagePars.caption) {
        ctx.pendingImageNode.caption = [
          node("w:br"),
          node("w:t", {}, [(0, reportUtils_1.newTextNode)(imagePars.caption)])
        ];
      }
    };
    function getImageData(imagePars) {
      var data = imagePars.data, extension = imagePars.extension;
      if (!extension) {
        throw new Error("If you return image `data`, make sure you return an extension as well!");
      }
      return { extension, data };
    }
    var processLink = function(ctx, linkPars) {
      return __awaiter(void 0, void 0, void 0, function() {
        var url, _a, label, id, relId, node, textRunPropsNode, link;
        return __generator(this, function(_b) {
          url = linkPars.url, _a = linkPars.label, label = _a === void 0 ? url : _a;
          ctx.linkId += 1;
          id = String(ctx.linkId);
          relId = "link".concat(id);
          ctx.links[relId] = { url };
          node = reportUtils_1.newNonTextNode;
          textRunPropsNode = ctx.textRunPropsNode;
          link = node("w:hyperlink", { "r:id": relId, "w:history": "1" }, [
            node("w:r", {}, [
              textRunPropsNode || node("w:rPr", {}, [node("w:u", { "w:val": "single" })]),
              node("w:t", {}, [(0, reportUtils_1.newTextNode)(label)])
            ])
          ]);
          ctx.pendingLinkNode = link;
          return [
            2
            /*return*/
          ];
        });
      });
    };
    var processHtml = function(ctx, data) {
      return __awaiter(void 0, void 0, void 0, function() {
        var id, relId, node, html;
        return __generator(this, function(_a) {
          ctx.htmlId += 1;
          id = String(ctx.htmlId);
          relId = "html".concat(id);
          ctx.htmls[relId] = data;
          node = reportUtils_1.newNonTextNode;
          html = node("w:altChunk", { "r:id": relId });
          ctx.pendingHtmlNode = html;
          return [
            2
            /*return*/
          ];
        });
      });
    };
    var BufferKeys = ["w:p", "w:tr", "w:tc"];
    var appendTextToTagBuffers = function(text, ctx, options) {
      if (ctx.fSeekQuery)
        return;
      var fCmd = options.fCmd, fInsertedText = options.fInsertedText;
      var type = fCmd ? "cmds" : "text";
      BufferKeys.forEach(function(key) {
        var buf = ctx.buffers[key];
        buf[type] += text;
        if (fInsertedText)
          buf.fInsertedText = true;
      });
    };
    function updateID(newNode, ctx) {
      ctx.imageAndShapeIdIncrement += 1;
      var id = String(ctx.imageAndShapeIdIncrement);
      newNode._attrs = __assign(__assign({}, newNode._attrs), { id: "".concat(id) });
    }
  }
});

// node_modules/docx-templates/lib/main.js
var require_main = __commonJS({
  "node_modules/docx-templates/lib/main.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMainDoc = exports.readContentTypes = exports.getMetadata = exports.listCommands = exports.parseTemplate = void 0;
    var zip_1 = require_zip();
    var xml_1 = require_xml();
    var preprocessTemplate_1 = __importDefault(require_preprocessTemplate());
    var processTemplate_1 = require_processTemplate();
    var reportUtils_1 = require_reportUtils();
    var errors_1 = require_errors();
    var debug_1 = require_debug();
    var DEFAULT_CMD_DELIMITER = "+++";
    var DEFAULT_LITERAL_XML_DELIMITER = "||";
    var CONTENT_TYPES_PATH = "[Content_Types].xml";
    var TEMPLATE_PATH = "word";
    var XML_FILE_REGEX = new RegExp("".concat(TEMPLATE_PATH, "\\/[^\\/]+\\.xml"));
    function parseTemplate(template) {
      return __awaiter(this, void 0, void 0, function() {
        var zip, contentTypes, mainDocument, main_template_path, templateXml, tic, parseResult, jsTemplate, tac;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              debug_1.logger.debug("Unzipping...");
              return [4, (0, zip_1.zipLoad)(template)];
            case 1:
              zip = _a.sent();
              debug_1.logger.debug("finding main template file (e.g. document.xml)");
              return [4, readContentTypes(zip)];
            case 2:
              contentTypes = _a.sent();
              mainDocument = getMainDoc(contentTypes);
              main_template_path = "".concat(TEMPLATE_PATH, "/").concat(mainDocument);
              debug_1.logger.debug("Reading ".concat(main_template_path, "..."));
              return [4, (0, zip_1.zipGetText)(zip, main_template_path)];
            case 3:
              templateXml = _a.sent();
              if (templateXml == null)
                throw new errors_1.TemplateParseError("".concat(mainDocument, " could not be found"));
              debug_1.logger.debug("".concat(main_template_path, " file length: ").concat(templateXml.length));
              debug_1.logger.debug("Parsing ".concat(main_template_path, " XML..."));
              tic = (/* @__PURE__ */ new Date()).getTime();
              return [4, (0, xml_1.parseXml)(templateXml)];
            case 4:
              parseResult = _a.sent();
              jsTemplate = parseResult;
              tac = (/* @__PURE__ */ new Date()).getTime();
              debug_1.logger.debug("".concat(main_template_path, " parsed in ").concat(tac - tic, " ms"));
              return [2, { jsTemplate, mainDocument, zip, contentTypes }];
          }
        });
      });
    }
    exports.parseTemplate = parseTemplate;
    function prepSecondaryXMLs(zip, main_doc_path, options) {
      return __awaiter(this, void 0, void 0, function() {
        var secondary_xml_files, prepped_secondaries, _i, secondary_xml_files_1, f, raw, js0, js;
        var _this = this;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              secondary_xml_files = [];
              zip.forEach(function(filePath) {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_a2) {
                    if (XML_FILE_REGEX.test(filePath) && filePath !== "".concat(TEMPLATE_PATH, "/").concat(main_doc_path) && filePath.indexOf("".concat(TEMPLATE_PATH, "/template")) !== 0) {
                      secondary_xml_files.push(filePath);
                    }
                    return [
                      2
                      /*return*/
                    ];
                  });
                });
              });
              secondary_xml_files.sort();
              prepped_secondaries = [];
              _i = 0, secondary_xml_files_1 = secondary_xml_files;
              _a.label = 1;
            case 1:
              if (!(_i < secondary_xml_files_1.length)) return [3, 5];
              f = secondary_xml_files_1[_i];
              debug_1.logger.debug("Reading ".concat(f, "..."));
              return [4, (0, zip_1.zipGetText)(zip, f)];
            case 2:
              raw = _a.sent();
              if (raw == null)
                throw new errors_1.TemplateParseError("".concat(f, " could not be read"));
              debug_1.logger.debug("".concat(f, " file length: ").concat(raw.length));
              debug_1.logger.debug("Parsing ".concat(f, " XML..."));
              return [4, (0, xml_1.parseXml)(raw)];
            case 3:
              js0 = _a.sent();
              js = (0, preprocessTemplate_1.default)(js0, options.cmdDelimiter);
              prepped_secondaries.push([js, f]);
              _a.label = 4;
            case 4:
              _i++;
              return [3, 1];
            case 5:
              return [2, prepped_secondaries];
          }
        });
      });
    }
    function createReport(options, _probe) {
      return __awaiter(this, void 0, void 0, function() {
        var template, data, queryVars, literalXmlDelimiter, createOptions, xmlOptions, _a, jsTemplate, mainDocument, zip, contentTypes, prepped_template, queryResult, query, prepped_secondaries, highest_img_id, ctx, result, report1, images1, links1, htmls1, reportXml, numImages, numHtmls, _i, prepped_secondaries_1, _b, js, filePath, result_1, report2, images2, links2, htmls2, xml, segments, documentComponent, ensureContentType, finalContentTypesXml, output;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              debug_1.logger.debug("Report options:", { attach: options });
              template = options.template, data = options.data, queryVars = options.queryVars;
              literalXmlDelimiter = options.literalXmlDelimiter || DEFAULT_LITERAL_XML_DELIMITER;
              createOptions = {
                cmdDelimiter: getCmdDelimiter(options.cmdDelimiter),
                literalXmlDelimiter,
                processLineBreaks: options.processLineBreaks != null ? options.processLineBreaks : true,
                noSandbox: options.noSandbox || false,
                runJs: options.runJs,
                additionalJsContext: options.additionalJsContext || {},
                failFast: options.failFast == null ? true : options.failFast,
                rejectNullish: options.rejectNullish == null ? false : options.rejectNullish,
                errorHandler: typeof options.errorHandler === "function" ? options.errorHandler : null,
                fixSmartQuotes: options.fixSmartQuotes == null ? false : options.fixSmartQuotes,
                processLineBreaksAsNewText: options.processLineBreaksAsNewText == null ? false : options.processLineBreaksAsNewText,
                maximumWalkingDepth: options.maximumWalkingDepth
              };
              xmlOptions = { literalXmlDelimiter };
              return [4, parseTemplate(template)];
            case 1:
              _a = _c.sent(), jsTemplate = _a.jsTemplate, mainDocument = _a.mainDocument, zip = _a.zip, contentTypes = _a.contentTypes;
              debug_1.logger.debug("Preprocessing template...");
              prepped_template = (0, preprocessTemplate_1.default)(jsTemplate, createOptions.cmdDelimiter);
              queryResult = null;
              if (!(typeof data === "function")) return [3, 4];
              debug_1.logger.debug("Looking for the query in the template...");
              return [4, (0, processTemplate_1.extractQuery)(prepped_template, createOptions)];
            case 2:
              query = _c.sent();
              debug_1.logger.debug("Query: ".concat(query || "no query found"));
              return [4, data(query, queryVars)];
            case 3:
              queryResult = _c.sent();
              return [3, 5];
            case 4:
              queryResult = data;
              _c.label = 5;
            case 5:
              return [4, prepSecondaryXMLs(zip, mainDocument, createOptions)];
            case 6:
              prepped_secondaries = _c.sent();
              highest_img_id = Math.max.apply(Math, __spreadArray(__spreadArray([], prepped_secondaries.map(function(_a2) {
                var s = _a2[0], _ = _a2[1];
                return (0, processTemplate_1.findHighestImgId)(s);
              }), false), [(0, processTemplate_1.findHighestImgId)(prepped_template)], false));
              debug_1.logger.debug("Generating report...");
              ctx = (0, processTemplate_1.newContext)(createOptions, highest_img_id);
              return [4, (0, processTemplate_1.produceJsReport)(queryResult, prepped_template, ctx)];
            case 7:
              result = _c.sent();
              if (result.status === "errors") {
                throw result.errors;
              }
              report1 = result.report, images1 = result.images, links1 = result.links, htmls1 = result.htmls;
              if (_probe === "JS")
                return [2, report1];
              debug_1.logger.debug("Converting report to XML...");
              reportXml = (0, xml_1.buildXml)(report1, xmlOptions);
              if (_probe === "XML")
                return [2, reportXml.toString("utf-8")];
              debug_1.logger.debug("Writing report...");
              (0, zip_1.zipSetText)(zip, "".concat(TEMPLATE_PATH, "/").concat(mainDocument), reportXml);
              numImages = Object.keys(images1).length;
              numHtmls = Object.keys(htmls1).length;
              return [4, processImages(images1, mainDocument, zip)];
            case 8:
              _c.sent();
              return [4, processLinks(links1, mainDocument, zip)];
            case 9:
              _c.sent();
              return [4, processHtmls(htmls1, mainDocument, zip)];
            case 10:
              _c.sent();
              _i = 0, prepped_secondaries_1 = prepped_secondaries;
              _c.label = 11;
            case 11:
              if (!(_i < prepped_secondaries_1.length)) return [3, 17];
              _b = prepped_secondaries_1[_i], js = _b[0], filePath = _b[1];
              ctx = (0, processTemplate_1.newContext)(createOptions, ctx.imageAndShapeIdIncrement);
              return [4, (0, processTemplate_1.produceJsReport)(queryResult, js, ctx)];
            case 12:
              result_1 = _c.sent();
              if (result_1.status === "errors") {
                throw result_1.errors;
              }
              report2 = result_1.report, images2 = result_1.images, links2 = result_1.links, htmls2 = result_1.htmls;
              xml = (0, xml_1.buildXml)(report2, xmlOptions);
              (0, zip_1.zipSetText)(zip, filePath, xml);
              numImages += Object.keys(images2).length;
              numHtmls += Object.keys(htmls2).length;
              segments = filePath.split("/");
              documentComponent = segments[segments.length - 1];
              return [4, processImages(images2, documentComponent, zip)];
            case 13:
              _c.sent();
              return [4, processLinks(links2, mainDocument, zip)];
            case 14:
              _c.sent();
              return [4, processHtmls(htmls2, mainDocument, zip)];
            case 15:
              _c.sent();
              _c.label = 16;
            case 16:
              _i++;
              return [3, 11];
            case 17:
              if (numImages || numHtmls) {
                debug_1.logger.debug("Completing [Content_Types].xml...");
                debug_1.logger.debug("Content types", { attach: contentTypes });
                ensureContentType = function(extension, contentType) {
                  var children = contentTypes._children;
                  if (children.filter(function(o) {
                    var _a2;
                    return !o._fTextNode && ((_a2 = o._attrs.Extension) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) === (extension === null || extension === void 0 ? void 0 : extension.toLowerCase());
                  }).length) {
                    return;
                  }
                  (0, reportUtils_1.addChild)(contentTypes, (0, reportUtils_1.newNonTextNode)("Default", {
                    Extension: extension,
                    ContentType: contentType
                  }));
                };
                if (numImages) {
                  debug_1.logger.debug("Completing [Content_Types].xml for IMAGES...");
                  ensureContentType("png", "image/png");
                  ensureContentType("jpg", "image/jpeg");
                  ensureContentType("jpeg", "image/jpeg");
                  ensureContentType("gif", "image/gif");
                  ensureContentType("bmp", "image/bmp");
                  ensureContentType("svg", "image/svg+xml");
                }
                if (numHtmls) {
                  debug_1.logger.debug("Completing [Content_Types].xml for HTML...");
                  ensureContentType("html", "text/html");
                }
                finalContentTypesXml = (0, xml_1.buildXml)(contentTypes, xmlOptions);
                (0, zip_1.zipSetText)(zip, CONTENT_TYPES_PATH, finalContentTypesXml);
              }
              debug_1.logger.debug("Zipping...");
              return [4, (0, zip_1.zipSave)(zip)];
            case 18:
              output = _c.sent();
              return [2, output];
          }
        });
      });
    }
    function listCommands(template, delimiter) {
      return __awaiter(this, void 0, void 0, function() {
        var opts, _a, jsTemplate, mainDocument, zip, secondaries, xmls, commands, _i, xmls_1, js, prepped, ctx;
        var _this = this;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              opts = {
                cmdDelimiter: getCmdDelimiter(delimiter),
                // Otherwise unused but mandatory options
                literalXmlDelimiter: DEFAULT_LITERAL_XML_DELIMITER,
                processLineBreaks: true,
                noSandbox: false,
                additionalJsContext: {},
                failFast: false,
                rejectNullish: false,
                errorHandler: null,
                fixSmartQuotes: false,
                processLineBreaksAsNewText: false
              };
              return [4, parseTemplate(template)];
            case 1:
              _a = _b.sent(), jsTemplate = _a.jsTemplate, mainDocument = _a.mainDocument, zip = _a.zip;
              return [4, prepSecondaryXMLs(zip, mainDocument, opts)];
            case 2:
              secondaries = _b.sent();
              xmls = __spreadArray([jsTemplate], secondaries.map(function(_a2) {
                var js2 = _a2[0], path = _a2[1];
                return js2;
              }), true);
              commands = [];
              _i = 0, xmls_1 = xmls;
              _b.label = 3;
            case 3:
              if (!(_i < xmls_1.length)) return [3, 6];
              js = xmls_1[_i];
              prepped = (0, preprocessTemplate_1.default)(js, opts.cmdDelimiter);
              ctx = (0, processTemplate_1.newContext)(opts);
              return [4, (0, processTemplate_1.walkTemplate)(void 0, prepped, ctx, function(data, node, ctx2) {
                return __awaiter(_this, void 0, void 0, function() {
                  var raw, _a2, cmdName, code, type;
                  return __generator(this, function(_b2) {
                    raw = (0, processTemplate_1.getCommand)(ctx2.cmd, ctx2.shorthands, ctx2.options.fixSmartQuotes);
                    ctx2.cmd = "";
                    _a2 = (0, processTemplate_1.splitCommand)(raw), cmdName = _a2.cmdName, code = _a2.cmdRest;
                    type = cmdName;
                    if (type != null && type !== "CMD_NODE") {
                      commands.push({
                        raw,
                        type,
                        code
                      });
                    }
                    return [2, void 0];
                  });
                });
              })];
            case 4:
              _b.sent();
              _b.label = 5;
            case 5:
              _i++;
              return [3, 3];
            case 6:
              return [2, commands];
          }
        });
      });
    }
    exports.listCommands = listCommands;
    function getMetadata(template) {
      return __awaiter(this, void 0, void 0, function() {
        function getText(t) {
          if (t._children.length === 0)
            return void 0;
          var n = t._children[0];
          if (n._fTextNode)
            return n._text;
          throw new Error("Not a text node");
        }
        function findNodeText(m, tag) {
          for (var _i = 0, _a = m._children; _i < _a.length; _i++) {
            var t = _a[_i];
            if (t._fTextNode)
              continue;
            if (t._tag === tag)
              return getText(t);
          }
          return;
        }
        var app_xml_path, core_xml_path, zip, appXml, coreXml, numberize;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              app_xml_path = "docProps/app.xml";
              core_xml_path = "docProps/core.xml";
              return [4, (0, zip_1.zipLoad)(template)];
            case 1:
              zip = _a.sent();
              return [4, parsePath(zip, app_xml_path)];
            case 2:
              appXml = _a.sent();
              return [4, parsePath(zip, core_xml_path)];
            case 3:
              coreXml = _a.sent();
              numberize = function(a) {
                var c = Number(a);
                if (Number.isFinite(c))
                  return c;
                return;
              };
              return [2, {
                pages: numberize(findNodeText(appXml, "Pages")),
                words: numberize(findNodeText(appXml, "Words")),
                characters: numberize(findNodeText(appXml, "Characters")),
                lines: numberize(findNodeText(appXml, "Lines")),
                paragraphs: numberize(findNodeText(appXml, "Paragraphs")),
                company: findNodeText(appXml, "Company"),
                template: findNodeText(appXml, "Template"),
                // from CoreXML
                title: findNodeText(coreXml, "dc:title"),
                subject: findNodeText(coreXml, "dc:subject"),
                creator: findNodeText(coreXml, "dc:creator"),
                description: findNodeText(coreXml, "dc:description"),
                lastModifiedBy: findNodeText(coreXml, "cp:lastModifiedBy"),
                revision: findNodeText(coreXml, "cp:revision"),
                lastPrinted: findNodeText(coreXml, "cp:lastPrinted"),
                created: findNodeText(coreXml, "dcterms:created"),
                modified: findNodeText(coreXml, "dcterms:modified"),
                category: findNodeText(coreXml, "cp:category")
              }];
          }
        });
      });
    }
    exports.getMetadata = getMetadata;
    function parsePath(zip, xml_path) {
      return __awaiter(this, void 0, void 0, function() {
        var xmlFile, node;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, (0, zip_1.zipGetText)(zip, xml_path)];
            case 1:
              xmlFile = _a.sent();
              if (xmlFile == null)
                throw new errors_1.TemplateParseError("".concat(xml_path, " could not be read"));
              return [4, (0, xml_1.parseXml)(xmlFile)];
            case 2:
              node = _a.sent();
              if (node._fTextNode)
                throw new errors_1.TemplateParseError("".concat(xml_path, " is a text node when parsed"));
              return [2, node];
          }
        });
      });
    }
    function readContentTypes(zip) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, parsePath(zip, CONTENT_TYPES_PATH)];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    }
    exports.readContentTypes = readContentTypes;
    function getMainDoc(contentTypes) {
      var MAIN_DOC_MIMES = [
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml",
        "application/vnd.ms-word.document.macroEnabled.main+xml"
      ];
      for (var _i = 0, _a = contentTypes._children; _i < _a.length; _i++) {
        var t = _a[_i];
        if (!t._fTextNode) {
          if (t._attrs.ContentType != null && MAIN_DOC_MIMES.includes(t._attrs.ContentType)) {
            var path = t._attrs.PartName;
            if (path) {
              return path.replace("/word/", "");
            }
          }
        }
      }
      throw new errors_1.TemplateParseError("Could not find main document (e.g. document.xml) in ".concat(CONTENT_TYPES_PATH));
    }
    exports.getMainDoc = getMainDoc;
    var processImages = function(images, documentComponent, zip) {
      return __awaiter(void 0, void 0, void 0, function() {
        var imageIds, relsPath, rels, _i, imageIds_1, imageId, _a, extension, imgData, imgName, imgPath, finalRelsXml;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              debug_1.logger.debug("Processing images for ".concat(documentComponent, "..."));
              imageIds = Object.keys(images);
              if (!imageIds.length)
                return [
                  2
                  /*return*/
                ];
              debug_1.logger.debug("Completing document.xml.rels...");
              relsPath = "".concat(TEMPLATE_PATH, "/_rels/").concat(documentComponent, ".rels");
              return [4, getRelsFromZip(zip, relsPath)];
            case 1:
              rels = _b.sent();
              for (_i = 0, imageIds_1 = imageIds; _i < imageIds_1.length; _i++) {
                imageId = imageIds_1[_i];
                _a = images[imageId], extension = _a.extension, imgData = _a.data;
                imgName = "template_".concat(documentComponent, "_").concat(imageId).concat(extension);
                debug_1.logger.debug("Writing image ".concat(imageId, " (").concat(imgName, ")..."));
                imgPath = "".concat(TEMPLATE_PATH, "/media/").concat(imgName);
                if (typeof imgData === "string") {
                  zip.file(imgPath, imgData, { base64: true });
                } else {
                  zip.file(imgPath, imgData, { binary: true });
                }
                (0, reportUtils_1.addChild)(rels, (0, reportUtils_1.newNonTextNode)("Relationship", {
                  Id: imageId,
                  Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                  Target: "media/".concat(imgName)
                }));
              }
              finalRelsXml = (0, xml_1.buildXml)(rels, {
                literalXmlDelimiter: DEFAULT_LITERAL_XML_DELIMITER
              });
              (0, zip_1.zipSetText)(zip, relsPath, finalRelsXml);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var processLinks = function(links, documentComponent, zip) {
      return __awaiter(void 0, void 0, void 0, function() {
        var linkIds, relsPath, rels, _i, linkIds_1, linkId, url, finalRelsXml;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              debug_1.logger.debug("Processing links for ".concat(documentComponent, "..."));
              linkIds = Object.keys(links);
              if (!linkIds.length) return [3, 2];
              debug_1.logger.debug("Completing document.xml.rels...");
              relsPath = "".concat(TEMPLATE_PATH, "/_rels/").concat(documentComponent, ".rels");
              return [4, getRelsFromZip(zip, relsPath)];
            case 1:
              rels = _a.sent();
              for (_i = 0, linkIds_1 = linkIds; _i < linkIds_1.length; _i++) {
                linkId = linkIds_1[_i];
                url = links[linkId].url;
                (0, reportUtils_1.addChild)(rels, (0, reportUtils_1.newNonTextNode)("Relationship", {
                  Id: linkId,
                  Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
                  Target: url,
                  TargetMode: "External"
                }));
              }
              finalRelsXml = (0, xml_1.buildXml)(rels, {
                literalXmlDelimiter: DEFAULT_LITERAL_XML_DELIMITER
              });
              (0, zip_1.zipSetText)(zip, relsPath, finalRelsXml);
              _a.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var processHtmls = function(htmls, documentComponent, zip) {
      return __awaiter(void 0, void 0, void 0, function() {
        var htmlIds, htmlFiles, relsPath, rels, _i, htmlIds_1, htmlId, htmlData, htmlName, htmlPath, finalRelsXml;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              debug_1.logger.debug("Processing htmls for ".concat(documentComponent, "..."));
              htmlIds = Object.keys(htmls);
              if (!htmlIds.length) return [3, 2];
              debug_1.logger.debug("Completing document.xml.rels...");
              htmlFiles = [];
              relsPath = "".concat(TEMPLATE_PATH, "/_rels/").concat(documentComponent, ".rels");
              return [4, getRelsFromZip(zip, relsPath)];
            case 1:
              rels = _a.sent();
              for (_i = 0, htmlIds_1 = htmlIds; _i < htmlIds_1.length; _i++) {
                htmlId = htmlIds_1[_i];
                htmlData = htmls[htmlId];
                htmlName = "template_".concat(documentComponent.replace(/\./g, "_"), "_").concat(htmlId, ".html");
                debug_1.logger.debug("Writing html ".concat(htmlId, " (").concat(htmlName, ")..."));
                htmlPath = "".concat(TEMPLATE_PATH, "/").concat(htmlName);
                htmlFiles.push("/".concat(htmlPath));
                (0, zip_1.zipSetText)(zip, htmlPath, Buffer.from(htmlData));
                (0, reportUtils_1.addChild)(rels, (0, reportUtils_1.newNonTextNode)("Relationship", {
                  Id: htmlId,
                  Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/aFChunk",
                  Target: "".concat(htmlName)
                }));
              }
              finalRelsXml = (0, xml_1.buildXml)(rels, {
                literalXmlDelimiter: DEFAULT_LITERAL_XML_DELIMITER
              });
              (0, zip_1.zipSetText)(zip, relsPath, finalRelsXml);
              _a.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var getRelsFromZip = function(zip, relsPath) {
      return __awaiter(void 0, void 0, void 0, function() {
        var relsXml;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, (0, zip_1.zipGetText)(zip, relsPath)];
            case 1:
              relsXml = _a.sent();
              if (!relsXml) {
                relsXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n        <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n        </Relationships>';
              }
              return [2, (0, xml_1.parseXml)(relsXml)];
          }
        });
      });
    };
    var getCmdDelimiter = function(delimiter) {
      if (!delimiter)
        return [DEFAULT_CMD_DELIMITER, DEFAULT_CMD_DELIMITER];
      if (typeof delimiter === "string")
        return [delimiter, delimiter];
      return delimiter;
    };
    exports.default = createReport;
  }
});

// node_modules/docx-templates/lib/index.js
var require_lib = __commonJS({
  "node_modules/docx-templates/lib/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createReport = exports.getMetadata = exports.listCommands = void 0;
    var main_1 = __importDefault(require_main());
    exports.createReport = main_1.default;
    var main_2 = require_main();
    Object.defineProperty(exports, "listCommands", { enumerable: true, get: function() {
      return main_2.listCommands;
    } });
    Object.defineProperty(exports, "getMetadata", { enumerable: true, get: function() {
      return main_2.getMetadata;
    } });
    __exportStar(require_errors(), exports);
    exports.default = main_1.default;
  }
});
export default require_lib();
/*! Bundled license information:

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/
//# sourceMappingURL=docx-templates.js.map
